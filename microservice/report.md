# Разделение монолита на сервисы

## Задание

Необходимо вынести систему диалогов в отдельный сервис.

Требования:
- Взаимодействия монолитного сервиса и сервиса диалогов реализовать через REST API или gRPC.
- Организовать сквозное логирование запросов (x-request-id).
- Предусмотреть то, что не все клиенты обновляют приложение быстро и кто-то может ходить через старое API (сохранение обратной совместимости).

## Реализация

- Сервис диалогов вынесен в отдельный микросервис `backend-dialog-server`. Код тоже разделён. Общая часть вынесена в модуль `pkg`, сервис диалогов перенесён в модуль `dialog`, основной монолитный сервис - в модуль `social`. Конфиги и Dockerfile также разделены. В будущем можно было бы разделить и БД Postgres в том случае, если в сервисе диалогов будет использоваться она, а не Tarantool. Тогда потребуется создать и отдельный `migrator` для миграций.
- В [docker-compose.yaml](../deployments/docker-compose.yaml) теперь поднимается 2 сервиса - основной монолитный сервис соц.сети `backend-social-server` и сервис диалогов `backend-dialog-server`.
- Взаимодействие сервиса диалогов и сервиса соц.сети происходит через HTTP. 
    - Клиенты могут вызывать непосредственно сам сервис диалогов (методы GET `/dialog/:user_id/list` и POST `/dialog/:user_id/send`). 
    - Также клиенты могут ходить через старое API (т.е. через сервис соц.сети), вызывая те же самые методы. Старое API в сервисе соц.сети проксирует запрос в сервис диалогов с тем же токеном, возвращает полученный ответ клиенту.
- Для реализации сквозного логирования и трассировки в сервисы добавлен `otel tracing`, с помощью которого впоследствии можно будет восстановить всю цепочку запросов:
    - В данном ДЗ просто генерируются `traceId`, `spanId` и пользовательский `x-request-id` (впоследствии можно будет передавать данные, например, в Jaeger). 
    - Значение `x-request-id` генерируется автоматически для каждого нового HTTP-запроса.
    - Для значимых действий (например, запросы в БД) создаются отдельные спаны. 
    - Данные по `traceId`, `spanId` и `x-request-id` передаются в контексте внутри приложения, а также по очереди, по HTTP (в заголовках) в сервис диалогов. 
    - При получении запроса в сервисе диалогов выполняется проверка наличия заголовка `x-request-id`. Если он есть, то используется он. Если же нет, то генерируется новый. Так мы сможем различать вызовы старого (через сервис соц.сети) и нового (через сервис диалогов) API.
    - При получении сообщения по очереди также происходит восстановление контекста на основе полученных заголовков.

## Запуск приложения
В [Makefile](../Makefile):
- `make up-memory` - поднять окружение (БД Postgres master, tarantool, кеши, очередь), автоматически применить миграции, поднять сервисы
- `make down-memory` - потушить окружение и сервисы
