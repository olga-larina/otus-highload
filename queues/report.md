# Онлайн обновление ленты новостей

## Задание

Необходимо разработать WebSocket сервер, при помощи которого подключённые клиенты будут сразу получать обновления постов своих друзей. Такой подход позволит сэкономить ресурсы и обновлять молниеносно ленты активных клиентов.  
Требования:
- реализовать отправку сообщений в канал /post/feed/posted через websocket 
- при обновлении ленты пользователя подписчику websocket'а должно приходить событие
- формирование лент должно работать через очередь
- при реализации обязательно обеспечить отправку только целевым пользователям это событие (можно применить Routing Key из RabbitMQ)

## Реализация

Обновление ленты пользователей реализовано следующим образом:
- Формирование лент работает через очередь RabbitMQ и сохраняется в кеше Redis (см. [ДЗ по кешированию](../caching/report.md))
    - События об изменении ленты (добавление / удаление друга, создание / обновление / удаление поста) отправляются в очередь RabbitMQ
    - Обработчик получает эти события, перестраивает кеши с подписчиками и лентой постов
    - События должен получить и обработать только один экземпляр сервиса (если впоследствии сервис будет масштабирован). Поэтому используется одна очередь с уникальными consumerTag.
- После обработки полученных событий об изменении лент запрашивается актуальная лента пользователя, продьюсер публикует сообщение с лентой постов в RabbitMQ, используя Routing Key с userId данного пользователя. Таким образом, из-за использования Direct exchange каждое сообщение доставляется только в очередь конкретного пользователя. В очередь также можно было бы отправлять только обновления ленты (но тогда необходимо добавить статус обновления - например, "сообщение удалено") и отслеживать, что именно поменялось в ленте (например, при добавлении друга будет много обновлений).
- Добавлен метод `/post/feed/posted` (`ws://localhost:8080/post/feed/posted`) с websocket. 
    - При получении запроса динамически для каждого пользователя создаётся отдельная очередь в RabbitMQ. Эта очередь уникальна для пользователя и для экземпляра сервиса. В неё и будут маршрутизироваться сообщения с актуальной лентой каждого конкретного пользователя на основе Routing Key. Такая реализация выбрана для того, чтобы при попадании запроса клиента на разные экземпляры сервиса он мог получать все обновлениям (на основе Routing Key события будут перенаправлены во все соответствующие очереди). 
    - При окончании запроса очередь удаляется. 
    - Также добавлена поддержка нескольких одновременных запросов со стороны одного пользователя (слушается одна и та же очередь и хранится счётчик активных запросов).
- В [ДЗ по кешированию](../caching/report.md) был описан способ реализации ленты с учётом селебрити. Такой же механизм можно будет применить и здесь при развитии сервиса. Т.е. для селебрити должны будут только добавляться посты (без обновления лент подписчиков), а для обычных пользователей - добавляться посты и обновляться ленты.
- В связи с тем, что для каждого пользователя и экземпляра используются отдельные очереди, сервис хорошо масштабируется горизонтально.

## Запуск приложения
В [Makefile](../Makefile):
- `make up` - поднять окружение (БД master, кеши, очередь), автоматически применить миграции, поднять сервис
- `make down` - потушить окружение и сервис